"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFromDirectory = exports.writeIndexFile = exports.getTypeFileNameFromSchema = exports.convertSchema = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const convertFilesInDirectory_1 = require("./convertFilesInDirectory");
const writeInterfaceFile_1 = require("./writeInterfaceFile");
const analyseSchemaFile_1 = require("./analyseSchemaFile");
/**
 * Apply defaults to the Partial Settings parameter
 *
 * @param settings Partial Setting object
 * @returns Complete Settings object
 */
function defaultSettings(settings) {
    const appSettings = Object.assign({
        useLabelAsInterfaceName: false,
        defaultToRequired: false,
        schemaFileSuffix: 'Schema',
        debug: false,
        fileHeader: `/**
 * This file was automatically generated by joi-to-typescript
 * Do not modify this file manually
 */`,
        sortPropertiesByName: true,
        commentEverything: false,
        ignoreFiles: [],
        indentationChacters: '  ',
        honorCastTo: [],
    }, settings);
    return appSettings;
}
function convertSchema(settings, joi, exportedName, root) {
    const appSettings = defaultSettings(settings);
    return analyseSchemaFile_1.convertSchemaInternal(appSettings, joi, exportedName, root);
}
exports.convertSchema = convertSchema;
function getTypeFileNameFromSchema(schemaFileName, settings) {
    return schemaFileName.endsWith(`${settings.schemaFileSuffix}.ts`)
        ? schemaFileName.substring(0, schemaFileName.length - `${settings.schemaFileSuffix}.ts`.length)
        : schemaFileName.replace('.ts', '');
}
exports.getTypeFileNameFromSchema = getTypeFileNameFromSchema;
/**
 * Write index.ts file
 *
 * @param settings - Settings Object
 * @param fileNamesToExport - List of file names that will be added to the index.ts file
 */
function writeIndexFile(settings, fileNamesToExport) {
    if (fileNamesToExport.length === 0) {
        // Don't write an index file if its going to export nothing
        return;
    }
    const exportLines = fileNamesToExport.map(fileName => `export * from './${fileName.replace(/\\/g, '/')}';`);
    const fileContent = `${settings.fileHeader}\n\n${exportLines.join('\n').concat('\n')}`;
    fs_1.writeFileSync(path_1.default.join(settings.typeOutputDirectory, 'index.ts'), fileContent);
}
exports.writeIndexFile = writeIndexFile;
/**
 * Create types from schemas from a directory
 *
 * @param settings - Configuration settings
 * @returns The success or failure of this operation
 */
async function convertFromDirectory(settings) {
    const appSettings = defaultSettings(settings);
    const filesInDirectory = await convertFilesInDirectory_1.convertFilesInDirectory(appSettings, path_1.default.resolve(appSettings.typeOutputDirectory));
    if (!filesInDirectory.types || filesInDirectory.types.length === 0) {
        throw new Error('No schemas found, cannot generate interfaces');
    }
    for (const exportType of filesInDirectory.types) {
        writeInterfaceFile_1.writeInterfaceFile(appSettings, exportType.typeFileName, filesInDirectory.types);
    }
    if (appSettings.indexAllToRoot || appSettings.flattenTree) {
        // Write index.ts
        writeIndexFile(appSettings, filesInDirectory.typeFileNames);
    }
    return true;
}
exports.convertFromDirectory = convertFromDirectory;
